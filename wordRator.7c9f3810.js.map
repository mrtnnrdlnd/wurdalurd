{"mappings":"A,C,KEKO,IAAM,EAA0C,CACnD,UAAW,CAAC,EAAM,IAAW,CAAC,EAAK,QAAQ,CAAC,GAC5C,cAAe,CAAC,EAAM,EAAQ,IAAa,EAAK,QAAQ,CAAC,IAAW,EAAK,MAAM,CAAC,KAAc,EAC9F,cAAe,CAAC,EAAM,EAAQ,IAAa,EAAK,MAAM,CAAC,KAAc,CACzE,ED2DA,KAAK,gBAAgB,CAAC,UAAW,SAAS,CAAC,EAEvC,IAAM,EAAS,AAZnB,SAAmB,CAAsB,CAAE,CAAsB,EAC7D,QAAQ,IAAI,CAAC,eACb,IAAM,EAAmB,IAAI,IACvB,EAAkB,EAAQ,GAAG,CAAC,AAAA,GAAS,CAAA,CAAE,KAAM,EAAM,OANpD,AA5CX,SAAS,EAAuB,CAAiB,CAAE,CAAkB,CAAE,CAAoB,CAAE,CAAmB,CAAE,CAAgB,CAAE,CAAa,EAC7I,GAAI,AAAiB,IAAjB,EAAM,MAAM,EAAU,AAAsB,IAAtB,EAAW,MAAM,CAAQ,OAAO,EAAM,MAAM,CAAG,EAEzE,IAEI,EAA2B,EAAE,CAC7B,EAA+B,EAAE,CACjC,EAA+B,EAAE,CAE/B,EAAS,CAAU,CAAC,EAAE,CACtB,EAAW,EAAU,MAAM,CACjC,GAAwB,CAAU,CAAC,EAAE,CACrC,EAAa,EAAW,KAAK,CAAC,GAE9B,IAAM,EAAU,CAAC,EAAE,EAAU,CAAC,EAAE,EAAM,CAAC,CACvC,GAAI,EAAM,GAAG,CAAC,GACT,CAAA,CAAA,UAAE,CAAS,CAAA,cAAE,CAAa,CAAA,cAAE,CAAa,CAAE,CAAG,EAAM,GAAG,CAAC,EAAA,MAExD,CACD,IAAK,IAAM,KAAK,EACR,AAAA,EAAQ,SAAS,CAAC,EAAG,EAAQ,GAC7B,EAAU,IAAI,CAAC,GAEV,AAAA,EAAQ,aAAa,CAAC,EAAG,EAAQ,GACtC,EAAc,IAAI,CAAC,GAEd,AAAA,EAAQ,aAAa,CAAE,EAAG,EAAQ,IACvC,EAAc,IAAI,CAAC,EAIvB,CAAA,EAAU,MAAM,CAAG,GACnB,EAAM,GAAG,CAAC,CAAC,EAAE,EAAU,CAAC,EAAE,EAAM,CAAC,CAAE,CAAC,UAAA,EAAW,cAAA,EAAe,cAAA,CAAa,EAEnF,CAMA,OAFA,AAnCY,GAiCH,CAAA,EAAU,MAAM,CAAG,EAAI,EAAuB,EAAW,EAAY,EAAW,EAAc,EAAU,MAAM,CAAC,EAAM,MAAM,CAAE,EAAO,EAAQ,KAAO,CAAA,EACnJ,CAAA,EAAc,MAAM,CAAG,EAAI,EAAuB,EAAW,EAAY,EAAe,EAAc,EAAc,MAAM,CAAC,EAAM,MAAM,CAAE,EAAO,EAAQ,KAAO,CAAA,EAC/J,CAAA,EAAc,MAAM,CAAG,EAAI,EAAuB,EAAW,EAAY,EAAe,EAAc,EAAc,MAAM,CAAC,EAAM,MAAM,CAAE,EAAO,EAAQ,KAAO,CAAA,EAG5K,EAGkC,GAM8C,EAAM,EANnC,EAM4C,EANhC,GAMuC,CAAA,GACjG,IAAI,CAAC,CAAC,EAAG,IAAM,EAAE,MAAM,CAAG,EAAE,MAAM,EAGnC,OAFA,QAAQ,OAAO,CAAC,eAChB,QAAQ,GAAG,CAAC,GACL,CACX,EAI6B,EAAE,IAAI,CAAC,OAAO,CAAE,EAAE,IAAI,CAAC,OAAO,EAEvD,KAAK,WAAW,CAAC,EACrB,E,C","sources":["<anon>","src/wordRator.ts","src/Filters.ts"],"sourcesContent":["(() => {\nvar $078c5ef6752db74b$exports = {};\nconst $ca24a5dcd488b51e$export$82462a21aead86ed = {\n    NotInWord: (word, letter)=>!word.includes(letter),\n    WrongPosition: (word, letter, position)=>word.includes(letter) && word.charAt(position) !== letter,\n    RightPosition: (word, letter, position)=>word.charAt(position) === letter\n};\nfunction $ca24a5dcd488b51e$export$1b001418845b471c(filterType, word, letter, position) {\n    const filterFunction = $ca24a5dcd488b51e$export$82462a21aead86ed[filterType];\n    if (!filterFunction) throw new Error(`Filter function not found for type: ${filterType}`);\n    return filterFunction(word, letter, position);\n}\n\n\nfunction $078c5ef6752db74b$var$rateWordRecursiveSplit(firstPart, secondPart, words, probability, cache, steps) {\n    if (words.length === 0 || secondPart.length === 0) return words.length * probability;\n    let count = 0;\n    let NotInWord = [];\n    let WrongPosition = [];\n    let RightPosition = [];\n    const letter = secondPart[0];\n    const position = firstPart.length;\n    firstPart = firstPart + secondPart[0];\n    secondPart = secondPart.slice(1);\n    const memoKey = `${firstPart}-${steps}`;\n    if (cache.has(memoKey)) ({ NotInWord: NotInWord, WrongPosition: WrongPosition, RightPosition: RightPosition } = cache.get(memoKey));\n    else {\n        for (const w of words){\n            if ((0, $ca24a5dcd488b51e$export$82462a21aead86ed).NotInWord(w, letter, position)) NotInWord.push(w);\n            else if ((0, $ca24a5dcd488b51e$export$82462a21aead86ed).WrongPosition(w, letter, position)) WrongPosition.push(w);\n            else if ((0, $ca24a5dcd488b51e$export$82462a21aead86ed).RightPosition(w, letter, position)) RightPosition.push(w);\n        }\n        if (firstPart.length < 4) cache.set(`${firstPart}-${steps}`, {\n            NotInWord: NotInWord,\n            WrongPosition: WrongPosition,\n            RightPosition: RightPosition\n        });\n    }\n    count += NotInWord.length > 0 ? $078c5ef6752db74b$var$rateWordRecursiveSplit(firstPart, secondPart, NotInWord, probability * NotInWord.length / words.length, cache, steps + \"N\") : 0;\n    count += WrongPosition.length > 0 ? $078c5ef6752db74b$var$rateWordRecursiveSplit(firstPart, secondPart, WrongPosition, probability * WrongPosition.length / words.length, cache, steps + \"W\") : 0;\n    count += RightPosition.length > 0 ? $078c5ef6752db74b$var$rateWordRecursiveSplit(firstPart, secondPart, RightPosition, probability * RightPosition.length / words.length, cache, steps + \"R\") : 0;\n    return count;\n}\nfunction $078c5ef6752db74b$var$rateWord(word, words, cache) {\n    return $078c5ef6752db74b$var$rateWordRecursiveSplit(\"\", word, words, 1.0, cache, \"\");\n}\nfunction $078c5ef6752db74b$var$rateWords(guesses, answers) {\n    console.time(\"ratingWords\");\n    const cache = new Map();\n    const timedRatedWords = answers.map((word)=>({\n            word: word,\n            rating: $078c5ef6752db74b$var$rateWord(word, guesses, cache)\n        })).sort((a, b)=>a.rating - b.rating);\n    console.timeEnd(\"ratingWords\");\n    console.log(cache);\n    return timedRatedWords;\n}\nself.addEventListener(\"message\", function(e) {\n    // e.data contains the data passed to the worker\n    const result = $078c5ef6752db74b$var$rateWords(e.data.answers, e.data.guesses) // Example operation\n    ;\n    // Post the result back to the main thread\n    self.postMessage(result);\n});\n\n})();\n//# sourceMappingURL=wordRator.7c9f3810.js.map\n","import {filters} from \"./Filters\"\n\ntype RatedWord = {\n    word: string,\n    rating: number\n}\n\ntype PartlyMemoizedRecursionCall = {NotInWord: Array<string>, WrongPosition: Array<string>, RightPosition: Array<string>};\n\ntype MemoCache = Map<string, PartlyMemoizedRecursionCall>;\n\nfunction rateWordRecursiveSplit(firstPart: string, secondPart: string, words: Array<string>, probability: number, cache: MemoCache, steps: string): number {\n    if (words.length === 0 || secondPart.length === 0) return words.length * probability;\n\n    let count = 0;\n\n    let NotInWord: Array<string> = [];\n    let WrongPosition: Array<string> = [];\n    let RightPosition: Array<string> = [];\n\n    const letter = secondPart[0];\n    const position = firstPart.length;\n    firstPart = firstPart + secondPart[0];\n    secondPart = secondPart.slice(1);\n\n    const memoKey = `${firstPart}-${steps}`;\n    if (cache.has(memoKey)) {\n        ({ NotInWord, WrongPosition, RightPosition } = cache.get(memoKey)!);\n    }\n    else {\n        for (const w of words) {\n            if (filters.NotInWord(w, letter, position)) {\n                NotInWord.push(w)\n            }\n            else if (filters.WrongPosition(w, letter, position)) {\n                WrongPosition.push(w)\n            }\n            else if (filters.RightPosition( w, letter, position)) {\n                RightPosition.push(w)\n            }\n        }\n\n        if (firstPart.length < 4) {\n            cache.set(`${firstPart}-${steps}`, {NotInWord, WrongPosition, RightPosition});\n        }\n    }\n    \n    count += NotInWord.length > 0 ? rateWordRecursiveSplit(firstPart, secondPart, NotInWord, probability * NotInWord.length/words.length, cache, steps + 'N') : 0;  \n    count += WrongPosition.length > 0 ? rateWordRecursiveSplit(firstPart, secondPart, WrongPosition, probability * WrongPosition.length/words.length, cache, steps + 'W') : 0;\n    count += RightPosition.length > 0 ? rateWordRecursiveSplit(firstPart, secondPart, RightPosition, probability * RightPosition.length/words.length, cache, steps + 'R') : 0;\n\n    return count;\n}\n\nfunction rateWord(word: string, words: Array<string>, cache: MemoCache): number {\n    return rateWordRecursiveSplit(\"\", word, words, 1.0, cache, \"\");\n}\n\nfunction rateWords(guesses: Array<string>, answers: Array<string>): Array<RatedWord> {\n    console.time(\"ratingWords\");\n    const cache: MemoCache = new Map();\n    const timedRatedWords = answers.map(word => ({ word: word, rating: rateWord(word, guesses, cache) }))\n    .sort((a, b) => a.rating - b.rating);\n    console.timeEnd(\"ratingWords\");\n    console.log(cache)\n    return timedRatedWords;\n}\n\nself.addEventListener('message', function(e) {\n    // e.data contains the data passed to the worker\n    const result = rateWords(e.data.answers, e.data.guesses) // Example operation\n    // Post the result back to the main thread\n    self.postMessage(result);\n});","\nexport type FilterType = 'NotInWord' | 'WrongPosition' | 'RightPosition';\n\nexport type WordFilter = (word: string, letter: string, position: number) => boolean;\n\nexport const filters: Record<FilterType, WordFilter> = {\n    NotInWord: (word, letter) => !word.includes(letter),\n    WrongPosition: (word, letter, position) => word.includes(letter) && word.charAt(position) !== letter,\n    RightPosition: (word, letter, position) => word.charAt(position) === letter\n}\n\nexport function applyFilter(filterType: FilterType, word: string, letter: string, position: number): boolean {\n    const filterFunction = filters[filterType];\n    if (!filterFunction) {\n        throw new Error(`Filter function not found for type: ${filterType}`);\n    }\n    return filterFunction(word, letter, position);\n}"],"names":["$ca24a5dcd488b51e$export$82462a21aead86ed","NotInWord","word","letter","includes","WrongPosition","position","charAt","RightPosition","self","addEventListener","e","result","$078c5ef6752db74b$var$rateWords","guesses","answers","console","time","cache","Map","timedRatedWords","map","rating","$078c5ef6752db74b$var$rateWordRecursiveSplit","firstPart","secondPart","words","probability","steps","length","slice","memoKey","has","get","w","push","set","count","sort","a","b","timeEnd","log","data","postMessage"],"version":3,"file":"wordRator.7c9f3810.js.map"}